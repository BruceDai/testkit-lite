#!/usr/bin/python
#
# Copyright (C) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU General Public License,
# version 2, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307 USA.
#
# Authors:
#              Tian, Xu <xux.tian@intel.com>
#              Wang, Jing <jing.j.wang@intel.com>
#              Wei, Zhang <wei.z.zhang@intel.com>
#              Zhang, Huihui <huihuix.zhang@intel.com>
#
# Description:
#   test runner startup

import os
import sys
import platform
import xml.etree.ElementTree as etree
from optparse import *
from tempfile import mktemp 
from datetime import datetime

_j = os.path.join
_e = os.path.exists
_d = os.path.dirname
_abspath = os.path.abspath

testkit_dir = "/opt/testkit/lite"
if not platform.system() == "Linux":
    testkit_dir = _d(_abspath(__file__))
    sys.path += [_j(testkit_dir)]

LOG_DIR = testkit_dir
PID_FILE = _j(LOG_DIR , "pid.log")
COMMON_FILTERS = {
        "suite":          [],
        "set":            [],
        "id":             [],
        "type":           [],
        "priority":       [],
        "category":       [],
        "status":         [],
        "component":      []}

#start testkit-lite in Singleton mode
try:
    with open(PID_FILE, "r") as fd:
        pid = fd.read(10).rstrip("\n")
        if pid:
            os.kill(int(pid), 9)
    with open(PID_FILE, "w") as fd:
        pid = str(os.getpid())
        fd.writelines(pid)
        os.chmod(PID_FILE, 0666)
except:
    pass

#get test engine, now we only got default engine
if "-E" in sys.argv:
    index = sys.argv.index("-E")
    try:
        engine = sys.argv[index + 1]
        engine = str(engine.strip()).lower()
    except IndexError:
        engine = "default"
else:
    engine = "default"

#init test engine here
try:
    exec "from testkitlite.engines.%s.runner import TRunner" % engine
    print "[ loading %s test engine ]" % engine
except ImportError, e:
    print e
    sys.argv.append("-h")

def varnarg(option, opt_str, value, parser):
    value = []
    import re
    for arg in parser.rargs:
        if re.search('^--.+', arg) or \
           re.search('^-[\D]', arg):
            break
        value.append(arg)
        
    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)

try:
    option_list = [
                    make_option("-f", "--testxml", dest="testxml",
                                action="callback", callback=varnarg,
                                help="Specify the test.xml"),
                    make_option("-D", "--dryrun", dest="bdryrun",
                                action="store_true",
                                help="Dry-run the selected test cases"),
                    make_option("-M", "--manual-only", dest="bmanualonly",
                                action="store_true",
                                help="Enable only manual tests"),
                    make_option("-A", "--auto-only", dest="bautoonly",
                                action="store_true",
                                help="Enable only auto tests"),
                    make_option("-o", "--output", dest="resultfile",
                                help="specify output file for result xml"),
                    make_option("-E", dest="engine", help="specific test engine"),
                    make_option("-e", dest="exttest", action="store",
                                help="launch external test with an executable file"),
                    make_option("--fullscreen", dest="fullscreen", action="store_true",
                                help="run web API test in full screen mode"),
                   make_option("--version", dest="version_info", action="store_true",
                                help="show version information"),
                  ]
    
    option_list.extend(map(lambda flt: \
                        make_option("--%s" % flt, dest="w%s" % flt, \
                                    action="callback", callback=varnarg, \
                                    help="Select the specified filter-rules : %s" % flt), COMMON_FILTERS))

    try:
        # untrusted behaviour of %%prog
        usage = "%%prog [options] -f <somewhere/test.xml>\n\
examples: %%prog  -f  <somewhere>/test.xml\n\
          %%prog  -f test.xml -D\n\
          %%prog  -f test.xml -A\n\
          %%prog  -f test.xml -M\n\
          %%prog  -f test1.xml test2.xml test3.xml ...\n\
          %%prog  -f test.xml -D -A --type type1 ...\n\
          %%prog  -f test.xml -D -A --type type1 --status ready ...\n\
\n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml --priority P0 --status ready ...\n\
\n\
Note: \n\
          1) TestLog is stored to %s/latest\n\
          2) %%prog enables both auto and manual tests by default\n\
          3) Obviously -A and -M are conflict options\n\
          4) -e option does not support -D mode" % (LOG_DIR)
    except:
        usage = None

    # detect non-params
    if len(sys.argv) == 1:
        sys.argv.append("-h")

    parser = OptionParser(option_list=option_list, usage=usage)

    (options, args) = parser.parse_args()
    
    # detect version option
    if options.version_info:
        raise ValueError("testkit-lite v2.2.1-1")

    # detect conflict
    if options.bautoonly and options.bmanualonly:
        raise ValueError("-A and -M are conflict")

    # create runner
    runner = TRunner()

    # apply dryrun
    if options.bdryrun:
        runner.set_dryrun(options.bdryrun)

    # apply user specify test result file
    if options.resultfile:
        runner.set_resultfile(options.resultfile)

    # apply filter
    wfilters = {}
    for flt in COMMON_FILTERS:
        if eval('options.w%s' % flt):
            wfilters[flt] = eval('options.w%s' % flt)

    # apply auto-only
    if not options.bautoonly:
        if options.bmanualonly:
            wfilters['execution_type'] = ["manual"]
        else:
            wfilters['execution_type'] = ["auto", "manual"]
    else:
        wfilters['execution_type'] = ["auto"]

    if options.fullscreen:
        runner.set_fullscreen(True)

    runner.add_filter_rules(**wfilters)

    if options.exttest:
        runner.set_external_test(options.exttest)

    if not options.testxml:
        print "[ Not specify a test xml... ]"
        sys.exit(1)

    # 1) prepare log dir
    session = datetime.today().isoformat('-')
    log_dir = _j(LOG_DIR, session)
    latest_dir = _j(LOG_DIR, "latest")
    try:
        if _e(latest_dir):
            os.remove(latest_dir)
        os.makedirs(log_dir)
        if os.name == "posix":
            os.symlink(log_dir, latest_dir)
    except OSError, e:
        print >> sys.stderr, "Create session log directory failed: %s\n" % e

    # 2) run test
    if len(options.testxml) > 1:
        testxml = mktemp(suffix='.xml', prefix='tests.', dir=log_dir)
        testxmls = set(options.testxml)
        root = etree.Element('test_definition', name="merged_test")
        for t in testxmls:
            parser = etree.parse(t)
            for suite in parser.getiterator('suite'):
                root.append(suite)
                
        try:
            with open(testxml, 'w') as fd:
                tree = etree.ElementTree(element=root)
                tree.write(testxml)
            print "[ merged testxmls into %s ]" % testxml
        except IOError, e:
            print "[ **merge testxmls failed**(%s) ]" % e
    else:
        testxml = (options.testxml)[0]
        
    try:
        runner.run(testxml, resultdir=log_dir)
    except Exception, e:
        print e

except KeyboardInterrupt, e:
    print >> sys.stderr, "\n\nExiting on user cancel."
    sys.exit(1)
except Exception, e:
    print >> sys.stderr, e
    sys.exit(1)
